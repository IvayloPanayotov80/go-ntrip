package main

import (
	"bufio"
	"bytes"
	"testing"
	"time"

	"github.com/goblimey/go-ntrip/rtcm"
)

// TestHandleMessages tests the handleMessages method.
func TestHandleMessages(t *testing.T) {
	// handleMessages reads the given data and writes any valid messages to
	// the given channel.  The test data contains one valid message of type
	// 1077 and some junk so the channel should contain a message of type
	// 1077 and a message of type NonRTCMMessage.

	var messageDataArray = [...]byte{

		// RTCM message type 1077 - signals from GPS satellites:
		0xd3, 0x00, 0xdc, // header - message length (0xdc - 220)
		// message, starting with  12-bit message type (0x435 - 1077), padded with null bytes
		// at the end.
		0x43, 0x50, 0x00, 0x67, 0x00, 0x97, 0x62, 0x00, 0x00, 0x08, 0x40, 0xa0, 0x65,
		0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x80, 0x00, 0x6d, 0xff, 0xa8, 0xaa, 0x26, 0x23, 0xa6, 0xa2,
		0x23, 0x24, 0x00, 0x00, 0x00, 0x00, 0x36, 0x68, 0xcb, 0x83, 0x7a, 0x6f, 0x9d, 0x7c, 0x04, 0x92,
		0xfe, 0xf2, 0x05, 0xb0, 0x4a, 0xa0, 0xec, 0x7b, 0x0e, 0x09, 0x27, 0xd0, 0x3f, 0x23, 0x7c, 0xb9,
		0x6f, 0xbd, 0x73, 0xee, 0x1f, 0x01, 0x64, 0x96, 0xf5, 0x7b, 0x27, 0x46, 0xf1, 0xf2, 0x1a, 0xbf,
		0x19, 0xfa, 0x08, 0x41, 0x08, 0x7b, 0xb1, 0x1b, 0x67, 0xe1, 0xa6, 0x70, 0x71, 0xd9, 0xdf, 0x0c,
		0x61, 0x7f, 0x19, 0x9c, 0x7e, 0x66, 0x66, 0xfb, 0x86, 0xc0, 0x04, 0xe9, 0xc7, 0x7d, 0x85, 0x83,
		0x7d, 0xac, 0xad, 0xfc, 0xbe, 0x2b, 0xfc, 0x3c, 0x84, 0x02, 0x1d, 0xeb, 0x81, 0xa6, 0x9c, 0x87,
		0x17, 0x5d, 0x86, 0xf5, 0x60, 0xfb, 0x66, 0x72, 0x7b, 0xfa, 0x2f, 0x48, 0xd2, 0x29, 0x67, 0x08,
		0xc8, 0x72, 0x15, 0x0d, 0x37, 0xca, 0x92, 0xa4, 0xe9, 0x3a, 0x4e, 0x13, 0x80, 0x00, 0x14, 0x04,
		0xc0, 0xe8, 0x50, 0x16, 0x04, 0xc1, 0x40, 0x46, 0x17, 0x05, 0x41, 0x70, 0x52, 0x17, 0x05, 0x01,
		0xef, 0x4b, 0xde, 0x70, 0x4c, 0xb1, 0xaf, 0x84, 0x37, 0x08, 0x2a, 0x77, 0x95, 0xf1, 0x6e, 0x75,
		0xe8, 0xea, 0x36, 0x1b, 0xdc, 0x3d, 0x7a, 0xbc, 0x75, 0x42, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// 24-bit Cyclic Redundancy Check
		0xfe, 0x69, 0xe8,

		'j', 'u', 'n', 'k', // junk which should be returned as a non-RTCM message.
	}

	var messageData []byte = messageDataArray[:]

	const wantNumMessages = 2
	const wantType0 = 1077
	const wantType1 = rtcm.NonRTCMMessage

	reader := bytes.NewReader(messageData)

	channels := make([]chan rtcm.Message, 0)
	ch := make(chan rtcm.Message, 10)
	channels = append(channels, ch)
	rtcmHandler := rtcm.New(time.Now(), nil)
	rtcmHandler.StopOnEOF = true

	// Test
	handleMessages(rtcmHandler, reader, channels)
	// Close the channel so that a channel reader knows when it's finished.
	close(ch)

	// Check.  Read the data back from the channel and check the message type
	// and validity flags.
	messages := make([]rtcm.Message, 0)
	for {
		message, ok := <-ch
		if !ok {
			// Done - chan is drained.
			break
		}
		messages = append(messages, message)
	}

	if len(messages) != wantNumMessages {
		t.Fatalf("want %d message, got %d messages", wantNumMessages, len(messages))
	}

	r0 := bytes.NewReader(messages[0].RawData)
	resultReader0 := bufio.NewReader(r0)
	message0, err0 := rtcmHandler.ReadNextMessage(resultReader0)
	if err0 != nil {
		t.Fatal(err0)
	}

	if message0 == nil {
		t.Fatal("message 0 is empty")
	}

	got0 := message0.MessageType
	if wantType0 != got0 {
		t.Fatalf("want message type %d, got message type %d", wantType0, got0)
	}

	if !message0.Complete {
		t.Error("not complete")
	}

	if !message0.CRCValid {
		t.Error("CRC check fails")
	}

	if !message0.Valid {
		t.Error("invalid")
	}

	r1 := bytes.NewReader(messages[1].RawData)
	resultReader1 := bufio.NewReader(r1)
	message1, err1 := rtcmHandler.ReadNextMessage(resultReader1)
	if err1 != nil {
		t.Fatal(err1)
	}

	if message1 == nil {
		t.Fatal("message 1 is empty")
	}

	got1 := message1.MessageType
	if wantType1 != got1 {
		t.Fatalf("want message type %d, got message type %d", wantType1, got1)
	}
}
